[gd_scene load_steps=5 format=3 uid="uid://113nsxeomwtt"]

[ext_resource type="Theme" uid="uid://bwqifwabah580" path="res://Themes/logic_block.tres" id="1_fqpkh"]

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_cbbac"]

[sub_resource type="GDScript" id="GDScript_qgnq2"]
resource_name = "block_shell"
script/source = "extends PanelContainer

@export var dragging_node: Node2D
@export var origin_node: VBoxContainer
var node
var moving = false
var to_mouse_position
var shadow_block
var spawning_shadow = false
var self_index
@export var is_given_block := false
var self_block_instance_path
@export var target_node: PanelContainer

var jump_drag # jump被拉动箭头时，替代 \"jump_to\" 节点的 Node2d 节点

signal moved(index)

func reset_nodes(dragging, origin):
	origin_node = origin
	dragging_node = dragging
	
	if origin_node.has_signal(\"block_move\"):
		origin_node.sort_children.connect(_on_any_block_moved)


func add_block( instance_path: String ):
	self_block_instance_path = instance_path
	node = load(instance_path)
	node = node.instantiate()
	
	if %BlockContainer.get_child_count() > 0:
		print(\"出错：一个BlockShell场景只能容纳一个积木。\")
		
	else:
		%BlockContainer.add_child(node)
		node.mouse_motion.connect(_on_block_mouse_motion)
		
		if node.name == \"Jump\":
			node.jumped.connect(_on_node_jumped)
			node.jumping.connect(_on_jump_block_jumping)
			node.parent = self
			
	pass



# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	
	
	
	if %BlockContainer.get_child_count() > 0:
		node = %BlockContainer.get_child(0)
	
	pass # Replace with function body.



# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	
	%Index.text = str(get_index())
	
	# jump_drag 处理
	if jump_drag != null:
		jump_drag.global_position.x = get_global_mouse_position().x
		
		# 计算目标位置
		if origin_node != null:
			
			var min_dis = INF
			var min_block = origin_node.get_child(0)
			
			for i in origin_node.get_children():
		
				if abs(i.global_position.y + i.size.y * 0.5 - get_global_mouse_position().y) < min_dis:
			
					min_block = i
					min_dis = abs(i.global_position.y + i.size.y * 0.5 - get_global_mouse_position().y)
					
			if get_global_mouse_position().x < origin_node.global_position.x:
				
				jump_drag.global_position.x = get_global_mouse_position().x
				
			else:
				
				jump_drag.global_position.x = min_block.global_position.x
			
			# 若jump目标是自己则不锁定
			jump_drag.global_position.y = min_block.global_position.y
			if min_block == self:
				node.c.value = -1
				node.jump_to = null
				set_jump_dictionary( self.get_index() )
			
			else:
				node.c.value = min_block.get_index()
				node.jump_to = min_block
				set_jump_dictionary( min_block.get_index() )
		
		# 松鼠标左键后消失
		if Input.is_mouse_button_pressed(MOUSE_BUTTON_LEFT) == false:
			
			jump_drag.queue_free()
		
		pass
		
	# 积木拖动处理
	if moving == true:
		%Index.visible = false
		
		global_position = get_global_mouse_position() + to_mouse_position
		
		# 计算阴影位置
		
		if shadow_block != null:
			
			if origin_node != null:
				
				var min_dis = INF
				var min_block = origin_node.get_child(0)
				
				for i in origin_node.get_children():
			
					if abs(i.global_position.y + i.size.y - get_global_mouse_position().y) < min_dis:
				
						min_block = i
						min_dis = abs(i.global_position.y + i.size.y - get_global_mouse_position().y)

				origin_node.move_child(shadow_block, min_block.get_index() )
				
		# 基于 shadow_block 进行预放置位置移动判定
		if self.global_position.x < origin_node.global_position.x - 100:
			modulate = Color(1 , 1 , 1 , 0.6)
		else:
			modulate = Color(1 , 1 , 1 , 1)
		
		
		#if self.global_position.y < shadow_block.global_position.y - shadow_block.size.y * 0.8:
		#	origin_node.move_child(shadow_block , max(shadow_block.get_index() - 1 , 0))
		#
		#if self.global_position.y > shadow_block.global_position.y + shadow_block.size.y * 0.8:
		#	origin_node.move_child(shadow_block , min(shadow_block.get_index() + 1 , origin_node.get_child_count()))
		
		
		# 当自身被松开
		if Input.is_mouse_button_pressed(MOUSE_BUTTON_LEFT) == false and Input.is_mouse_button_pressed(MOUSE_BUTTON_RIGHT) == false:
			
			if self.global_position.x < origin_node.global_position.x - 100:
				if shadow_block != null:
					
					shadow_block.queue_free()
				self.queue_free()
			
			
			
			moving = false
			%Index.visible = not is_given_block
			reparent(origin_node)
			
			origin_node.move_child(self , shadow_block.get_index())
			emit_signal(\"moved\", shadow_block.get_index())
				
			shadow_block.queue_free()
				
			origin_node.emit_signal(\"block_move\")
			
	else:
		
		%Index.visible = not is_given_block
		pass
	

func _on_block_mouse_motion(pressed):
	
	# 检测到自身被按下
	if pressed:
		
		if is_given_block or Input.is_mouse_button_pressed(MOUSE_BUTTON_RIGHT) == true:
			
			var child_block_shell = add_block_shell(self_block_instance_path)
			
			child_block_shell.load_value( (node.compile().erase( node.compile().length() - 1 , 1)).split(\" \") )

		else:
			
			self_index = self.get_index()
				
			# 把自己转移到Dragging节点下
			
			to_mouse_position = global_position - get_global_mouse_position() + Vector2(40 , 0)
			reparent(dragging_node)
			moving = true
					
			# 在自身位置生成一个虚影
				
			spawn_shadow()

	else:
		pass

# 生成积木阴影，一般在积木被拿起时生成，用于预览积木放下的位置
func spawn_shadow():
	
	shadow_block = PanelContainer.new()
	shadow_block.custom_minimum_size = self.size
	origin_node.add_child(shadow_block)

	return(shadow_block)
	
# 生成并配置一个与自身同类的节点。
func add_block_shell(instance):
	var block_shell = load(\"res://Blocks/block_shell.tscn\")
	block_shell = block_shell.instantiate()
	dragging_node.add_child(block_shell)
	block_shell.add_block(instance)
	
	block_shell.reset_nodes(dragging_node, origin_node)
	block_shell.self_index = 0
	block_shell.to_mouse_position = global_position - get_global_mouse_position()
	block_shell.spawn_shadow()
	block_shell.moving = true

	
	return(block_shell)

# 这个函数目前没有用。检测鼠标进入自身的判定方法已弃用。
func _on_mouse_entered() -> void:
	
	origin_node.jump = self

	pass # Replace with function body.

# 包含的积木为jump且其指向目标改变时发出触发。
func _on_node_jumped(jump_index):
	
	if node.name == \"Jump\":
		
		if node.has_signal(\"_on_c_value_changed\") and jump_index == \"fuck you\":
			target_node = origin_node.get_child(node.c.value)
			node.jump_to = target_node
		
		elif jump_index == -1:
			target_node = null
			node.jump_to = null
			set_jump_dictionary( self.get_index() )
		
		else:
			target_node = origin_node.get_child(int(jump_index))
			node.jump_to = target_node
			set_jump_dictionary( jump_index )
	
	pass

# UserBlocks（容纳这些blockshell的节点）重新排列子节点时触发，主要用于更新jump值。
func _on_any_block_moved():
	
	
	if node.name == \"Jump\":
		if target_node != null:
			node.set_jump( target_node.get_index() )
			set_jump_dictionary( target_node.get_index() )
	pass

# 传递从更上方传来的同名方法。目前此方法的发出源仅见于editor的绑定脚本。
func load_value(value : Array):
	node.load_value(value)

# jump箭头被拖动时触发。用来实现拖动效果，无法响应只更改jump值的情况。
func _on_jump_block_jumping():
	
	if is_given_block:
		pass
		
	else:
		# 若 Dragging 已有子节点（正在有其他对象被拖动），则不执行任何操作
		if dragging_node.get_child_count() > 0:
			return null
			
		jump_drag = PanelContainer.new()
		dragging_node.add_child(jump_drag)

# 向UserBlocks声明自己的jump信息。
func set_jump_dictionary(index : int):
	if \"jump_lines\" in origin_node:
		origin_node.jump_lines[self] = [self.get_index(), index]
"

[sub_resource type="StyleBoxEmpty" id="StyleBoxEmpty_q14p2"]

[node name="BlockShell" type="PanelContainer"]
offset_right = 946.0
offset_bottom = 40.0
size_flags_horizontal = 3
size_flags_vertical = 0
theme = ExtResource("1_fqpkh")
theme_override_styles/panel = SubResource("StyleBoxEmpty_cbbac")
script = SubResource("GDScript_qgnq2")

[node name="HBoxContainer" type="HBoxContainer" parent="."]
layout_mode = 2

[node name="Index" type="Label" parent="HBoxContainer"]
unique_name_in_owner = true
modulate = Color(0.46, 0.46, 0.46, 0.458824)
custom_minimum_size = Vector2(40, 0)
layout_mode = 2
text = "1"

[node name="BlockContainer" type="PanelContainer" parent="HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 0
theme_override_styles/panel = SubResource("StyleBoxEmpty_q14p2")

[connection signal="gui_input" from="." to="." method="_on_gui_input"]
[connection signal="mouse_entered" from="." to="." method="_on_mouse_entered"]
